/**
 * createBoardBitmap converts the provided multidimensional array into
 * where the provided player (or object) is represented by 1s,
 * and anything else (other player, empty) is represented by 0s.
 *
 * This was originally in the gameboard class and used after each play.  Since it converts every time
 * It will scale at n^2, which isn't great if we want some crazy huge boards.  So pulled it out, genericized it,
 * and added the 'update' function that can take a
 *
 * If opt to update the bitmap after each move using the updateBitmap function, then createBitmap really
 * only needs to be called once at the start of a game and is valid for both players.
 *
 * @param p T What to flag as a 1.  Will always be a player at this time.
 * @param b T[][] 2d array of 'p's to parse
 * @private
 */
const createBitmap = <T>(p: T, b: T[][]): number[] => {
  const boardMap: number[] = [];
  for (const x of b) {
    let row = '';
    for (const y of x) {
      row += (y === p) ? '1' : '0';
    }
    boardMap.push(+`0b${row}`);
  }
  return boardMap;
};

/**
 * updateBitmap takes an existing bitmap generated by the above function and flips a single bit,
 * returning the result.
 *
 * Updates the map in place
 *
 * TODO Switch bitmap to its own type and set this as a method?
 *
 * @param map number[] Array of bits, with each element being a row in the original board
 * @param row number row to update
 * @param col column to flip to 1
 * @return void
 */
const updateBitmap = (map: number[], row: number, col: number): void => {
  try {
    map[row] = map[row] | (0b1 << map.length - col - 1);
  } catch(e) {
    throw new Error(`unable to update bitmap: ${(e as Error).message}`);
  }
};

export {
  updateBitmap,
  createBitmap,
};